#### 1.状态模式：  

（1）相同的操作下，不同类型的防御塔对金币数量的影响不同，每次都要用if···else if语句判断防御塔的类型，进而影响金币数量的变化。将每种防御塔的类型抽象成一种状态。  

```c#
public abstract class State
{
    public abstract void WFvfds(GameObject gameObject, Mymoney my, int index);
}
public class State01 : State
{
    public override void WFvfds(GameObject gameObject, Mymoney my, int index)
    {
        if (gameObject.tag=="01")
        {
            if (index == 1)
            {
                my.Money(-100);
            }
            else if (index == 2)
            {
                my.Money(-180);
            }
            else if (index == 3)
            {
                my.Money(80);
            }
            else if (index == 4)
            {
                my.Money(224);
            }
        }
        else
        {
            new State02().WFvfds(gameObject,my,index);
        }
    }
}
public class State02 : State
{
    public override void WFvfds(GameObject gameObject, Mymoney my, int index)
    {
        if (gameObject.tag == "02")
        {
            if (index == 1)
            {
                my.Money(-120);
            }else if (index == 2)
            {
                my.Money(-200);
            }
            else if (index == 3)
            {
                my.Money(96);
            }
            else if (index == 4)
            {
                my.Money(272);
            }
        }
        else
        {
            new State03().WFvfds(gameObject, my, index);
        }
    }
}
public class State03 : State
{
    public override void WFvfds(GameObject gameObject, Mymoney my, int index)
    {
        if (gameObject.tag == "03")
        {
            if (index == 1)
            {
                my.Money(-160);
            }
            else if (index == 2)
            {
                my.Money(-240);
            }
            else if (index == 3)
            {
                my.Money(128);
            }
            else if (index == 4)
            {
                my.Money(312);
            }
        }
        else
        {
            new State04().WFvfds(gameObject, my, index);
        }
    }
}
public class State04 : State
{
    public override void WFvfds(GameObject gameObject, Mymoney my, int index)
    {
        if (gameObject.tag == "04")
        {
            if (index == 1)
            {
                my.Money(-180);
            }
            else if (index == 2)
            {
                my.Money(-260);
            }
            else if (index == 3)
            {
                my.Money(156);
            }
            else if (index == 4)
            {
                my.Money(324);
            }
        }
      
    }
}

```



（2）防御塔可以建立或销毁，用一个int值来标记防御塔的具体操作。   

```c#
  public override void WFvfds(GameObject gameObject, Mymoney my, int index)
    {
        if (gameObject.tag=="01")
        {
            if (index == 1)
            {
                my.Money(-100);
            }
            else if (index == 2)
            {
                my.Money(-180);
            }
            else if (index == 3)
            {
                my.Money(80);
            }
            else if (index == 4)
            {
                my.Money(224);
            }
        }
        else
        {
            new State02().WFvfds(gameObject,my,index);
        }
    }
```

```c#
 if (hit.transform.childCount == 0)
 {
       new State01().WFvfds(game, my, 1);
       if (Mymoney.isBuildmodel)
       {
            Model = Instantiate(Resources.Load(MainController.modelname, typeof(GameObject)) as GameObject);
            Model.transform.parent = hit.transform;
            Model.transform.localPosition = Vector3.zero;
        }
 }
 else if (hit.transform.childCount != 0)
 {
        new State01().WFvfds(hit.transform.GetChild(0).gameObject, my, 3);
        Destroy(hit.transform.GetChild(0).gameObject);
  }
```



2.享元模式：  

(1)怪物包括狮子、狐狸和青蛙，它们都有共同的属性：名字、最大血量和速度，定义EnemyCharacter类声明这些共同属性。

```c#
public class EnemyCharacter
{
    private string name;
    private float maxHp;
    private float speed;

    public EnemyCharacter(string name,float maxHp,float speed)
    {
        this.MaxHp = maxHp;
        this.Name = name;
        this.speed = speed;
    }

    public string Name { get => name; set => name = value; }
    public float MaxHp { get => maxHp; set => maxHp = value; }
    public float Speed { get => speed; set => speed = value; }
}

```

（2）在CharacterFactory 中池化三种怪物的属性。

```c#
public class CharacterFactory 
{
    private static CharacterFactory instance;
    private  Dictionary<int, EnemyCharacter> dic = new Dictionary<int, EnemyCharacter>();
    public  CharacterFactory()
    {
        dic.Add(1, new EnemyCharacter("Enemy_01", 100, 8));
        dic.Add(2, new EnemyCharacter("Enemy_02", 80, 5));
        dic.Add(3, new EnemyCharacter("Enemy_03", 60, 3));
    }

    public static CharacterFactory Instance
    {
        get
        {
            if (instance == null)
            {
                instance =new CharacterFactory ();
            }
            return instance;

        }

    }

    public  EnemyCharacter JianCha(int ID)
    {   
        if (dic.ContainsKey(ID))
        {
            return dic[ID];
        }
        return null;
    }
}
```



#### 3.单例模式：  

（1）CharacterFactory类利用单例模式实现多个同种类型的怪物只访问仅实例了一次属性值。

```c#
 public static CharacterFactory Instance
    {
        get
        {
            if (instance == null)
            {
                instance =new CharacterFactory ();
            }
            return instance;

        }

    }
```

以青蛙怪物为例子,所有实例化

```c#
public class qingwa :Enemy
{
    public qingwa()
    {
        enemyCharacter = CharacterFactory.Instance.JianCha(3);
    }
}
```

#### 4.建造者模式的仿写：

（1）我对建造者模式的理解，所有的类可以分为三大类：是什么？怎么做？去做？它将构成和表现分离。

（2）血量条资源与怪物类参考建造者模式结合在一起，当前项目由于项目需要，我将怎么做和去做结合在了一起，代码：EnemyBuilder脚本， Enemy和BloodManager 类。

```c#
public class Enemy 
{
    public EnemyCharacter enemyCharacter;
    public float nowHp;
    public Slider monsterBloodBar;
}
```

```c#
public class BloodManager 
{
    private static BloodManager instance;

    public static BloodManager Instance
    {
        get
        {
            if(instance == null)
            {
                instance = new BloodManager();
            }
            return instance;
        }
    }

    public void  SetBlood(Enemy enemy)
    {
        enemy.monsterBloodBar.value=enemy.nowHp / enemy.enemyCharacter.MaxHp;
    }
}
```

```c#
public class EnemyBuilder : MonoBehaviour
{
    public Enemy enemy;
    public Slider blood;

    void Awake()
   {
       if(transform.gameObject.name== "Enemy_01(Clone)")
       {
            enemy = new fox();
        }else if (transform.gameObject.name == "Enemy_02(Clone)")
        {
            enemy = new qingwa();
        }
        else if (transform.gameObject.name == "Enemy_03(Clone)")
        {
             enemy = new wolf();
         }

        enemy.nowHp = enemy.enemyCharacter.MaxHp;
        enemy.monsterBloodBar = blood;
    }
    private void OnTriggerEnter(Collider other)
    {
        if (other.tag == "Bull")
        {
            enemy.nowHp -= other.transform.gameObject.GetComponent<BullMove>().damage;
        }
        if (other.tag == "End")
        {
            Destroy(gameObject);
        }
    }
  
    void Update()
    {
        BloodManager.Instance.SetBlood(enemy);
    }
}
```

