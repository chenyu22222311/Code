### 1.工厂方法模式

定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。核心工厂类不再负责产品的创建，这样核心类成为一个抽象工厂角色，仅负责具体工厂子类必须实现的接口，这样进一步抽象化的好处是使得工厂方法模式可以使系统在不修改具体工厂角色的情况下引进新的产品。

------

#### UML图

![工厂方法模式](C:\Users\DELL\Desktop\工厂方法模式.jpg)

------

```c#
    class TankBase
    {
       public virtual void TankShoot()
        {
            Console.WriteLine("开始射击");
        }
    }
    class TankA : TankBase
    {
        public override void TankShoot()
        {
            base.TankShoot();
            Console.WriteLine("我是坦克A,一次发射一枚炮弹.");
        }
    }
    class TankB : TankBase
    {
        public override void TankShoot()
        {
            base.TankShoot();
            Console.WriteLine("我是坦克B,一次发射一枚炮弹.");
        }
    }
    class TankC : TankBase
    {
        public override void TankShoot()
        {
            base.TankShoot();
            Console.WriteLine("我是坦克C,一次发射一枚炮弹.");
        }
    }
    interface TankFctory
    {
        TankBase CreateTank();

    }
    class TankAFctory : TankFctory
    {
        public TankBase CreateTank()
        {
            return new TankA();
        }
    }
    class TankBFctory : TankFctory
    {
        public TankBase CreateTank()
        {
            return  new TankB();
        }
    }
    class TankCFctory : TankFctory
    {
        public TankBase CreateTank()
        {
            return new TankC();
        }
    }
    public class TankManager
    {
        public static void Main(string [] args)
        {
            TankFctory f1 = new TankAFctory();
            f1.CreateTank().TankShoot();
            TankFctory f2 = new TankBFctory();
            f2.CreateTank().TankShoot();
            TankFctory f3 = new TankCFctory();
            f3.CreateTank().TankShoot();
            Console.ReadLine();
        }
    }
```



### 2.状态模式

在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。

------

#### 介绍

**意图：**允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。

**主要解决：**对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。

**何时使用：**代码中包含大量与对象状态有关的条件语句。

**如何解决：**将各种具体的状态类抽象出来。

**关键代码：**通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if...else 等条件选择语句。

**使用场景：** 1、行为随状态改变而改变的场景。 2、条件、分支语句的代替者。

------

```c#
  public abstract class State
    {
        public abstract void Handle(Context context);
        
    }
    public class Context
    {
        public State state;
        public Context(State state)
        {
            this.state = state;
        }
        public void Request()
        {
            state.Handle(this);
        }

    }
    public class ConcreteStateA : State
    {
        public override void Handle(Context context)
        {
            Console.WriteLine("当前的状态是A");
            context.state = new ConcreteStateB();
        }
    }
    public class ConcreteStateB : State
    {
        public override void Handle(Context context)
        {
            Console.WriteLine("当前的状态是B");
            context.state = new ConcreteStateA();
        }
    }
    class Program
    {
        public static void Main(string[] args)
        {
            Context c = new Context(new ConcreteStateA());
            c.Request();
            c.Request();
            c.Request();
            c.Request();
            Console.ReadLine();
        }
    }
```



### 3.单例模式

单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

**注意：**

- 1、单例类只能有一个实例。
- 2、单例类必须自己创建自己的唯一实例。
- 3、单例类必须给所有其他对象提供这一实例。    

------

#### 介绍

**意图：**保证一个类仅有一个实例，并提供一个访问它的全局访问点。

**主要解决：**一个全局使用的类频繁地创建与销毁。

**何时使用：**当您想控制实例数目，节省系统资源的时候。

**如何解决：**判断系统是否已经有这个单例，如果有则返回，如果没有则创建。

**关键代码：**构造函数是私有的。

**优点：**

- 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。
- 2、避免对资源的多重占用（比如写文件操作）。

**缺点：**没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。

**注意事项：**防止多线程同时进入造成 对象 被多次实例化。

------

```c#
class Singleton
    {
        public static Singleton Instance;
        private static object locker = new object();
        public static Singleton GetInstance()
        {
            if (Instance==null)
            {
                lock (locker)
                {
                    if (Instance==null)
                    {
                        Instance = new Singleton();
                    }
                 
                }
            }
            return Instance;
        }
        public static void Main(string[] args)
        {
            Singleton s1 =Singleton.GetInstance();
            Singleton s2 = Singleton.GetInstance();
            Console.Write("s1是否等于s2:{0}", s1 == s2);
            Console.ReadLine();
        }
    }
```



### 4.享元模式

享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。

------

#### 介绍

**意图：**运用共享技术有效地支持大量细粒度的对象。

**主要解决：**在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。

**何时使用：** 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。

**如何解决：**用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。

**关键代码：**用 列表存储这些对象。

**优点：**大大减少对象的创建，降低系统的内存，使效率提高。

**缺点：**提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。

**使用场景：** 1、系统有大量相似对象。 2、需要缓冲池的场景。

**注意事项：** 1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。 2、这些类必须有一个工厂对象加以控制。

------

```c#
 //享元模式
    public abstract class Shape
    {
       public  abstract  void  Draw();
    }
    public class Circle : Shape
    {
        private String color;
        private int x;
        private int y;
        private int radius;

        public Circle(String color)
        {
            this.color = color;
        }

        public void setX(int x)
        {
            this.x = x;
        }

        public void setY(int y)
        {
            this.y = y;
        }

        public void setRadius(int radius)
        {
            this.radius = radius;
        }

       
    public override void Draw()
        {
           Console.WriteLine("Circle: Draw() [Color : " + color
               + ", x : " + x + ", y :" + y + ", radius :" + radius);
        }
    }
    public class ShapeFactory
    {
        private static  Dictionary<String, Circle> list = new Dictionary<String, Circle>();

        public static Shape getCircle(String color)
        {
            Circle circle ;
            list.TryGetValue(color, out circle);

            if (circle == null)
            {
                circle = new Circle(color);
                list.Add(color, circle);
               Console.WriteLine("Creating circle of color : " + color);
            }
            return circle;
        }
    }

    public class FlyweightPatternDemo
    {
        private static  String [] colors = 
      { "Red", "Green", "Blue", "White", "Black" };
        public static void Main(string[] args)
        {

            for (int i = 0; i < 20; ++i)
            {
                Circle circle =
                   (Circle)ShapeFactory.getCircle(getRandomColor());
                circle.setX(getRandomX());
                circle.setY(getRandomY());
                circle.setRadius(100);
                circle.Draw();
            }
            Console.ReadLine();
        }
         private static String getRandomColor()
        {
            return colors[(int)( new Random().Next(0, colors.Length) )];
        }
        private static int getRandomX()
        {
            return (int)(new Random().Next(1,100)  );
        }
        private static int getRandomY()
        {
            return (int)(new Random().Next(1,100));
        }
    }
```



### 5.抽象工厂模式

抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。



在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。

------

#### 介绍

**意图：**提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

**主要解决：**主要解决接口选择的问题。

**何时使用：**系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。

**如何解决：**在一个产品族里面，定义多个产品。

**关键代码：**在一个工厂里聚合多个同类产品。



**优点：**当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。

**缺点：**产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。

------

```c#
  class Tank
    {
        public virtual void TankShoot()
        {
            Console.WriteLine("开始射击");
        }
    }
    class Tank1 : Tank
    {
        public override void TankShoot()
        {
            base.TankShoot();
            Console.WriteLine("我是坦克1,一次发射一枚炮弹.");
        }
    }
    class Tank2 : Tank
    {
        public override void TankShoot()
        {
            base.TankShoot();
            Console.WriteLine("我是坦克2,一次发射一枚炮弹.");
        }
    }
    class Tank3 : Tank
    {
        public override void TankShoot()
        {
            base.TankShoot();
            Console.WriteLine("我是坦克3,一次发射一枚炮弹.");
        }
    }
    interface Fctory
    {
        TankBase CreateTank();
        Tank Createtank();

    }
    class Fctory1 : Fctory
    {
        public TankBase CreateTank()
        {
            return new TankA();
        }
        public Tank Createtank()
        {
            return new Tank1();
        }
    }
    class Fctory2: Fctory
    {
        public TankBase CreateTank()
        {
            return new TankB();
        }
        public Tank Createtank()
        {
            return new Tank2();
        }
    }
    class Fctory3 : Fctory
    {
        public TankBase CreateTank()
        {
            return new TankC();
        }
        public Tank Createtank()
        {
            return new Tank3();
        }
    }
    public class Manager
    {
        public static void Main(string[] args)
        {
            Fctory f1 = new Fctory1();
            f1.CreateTank().TankShoot();
            f1.Createtank().TankShoot();
            Fctory f2 = new Fctory2();
            f2.CreateTank().TankShoot();
            f2.Createtank().TankShoot();
            Fctory f3 = new Fctory3();
            f3.CreateTank().TankShoot();
            f3.Createtank().TankShoot();
            Console.ReadLine();
        }
    }

```



